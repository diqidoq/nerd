nerd - nonlinear expression of related data
===========================================

nerd is just an idea * a brainstorming paper * a "dream" of an API driven modern, flexible and limitless modular server based data and evaluation bundler extendable, e.g. with a browser based interface behavior, like web applications have * this way upside down makes it possible to build limitless web services * web sites * social networks * pin-boards * blogs * and even (like the name suggests) complex Extended Data Processing systems like project management or company base management in the "cloud" (I hate that word) * 

passed on principles of static or pseudo-dynamic data shoving called "websites" or "web content" which tries to extend upside down to a more complex system is legacy * bundling REAL modular functionality and building extendable method boilerplates, which can adapt almost everything thinkable * this is the new way to go.

The idea sounds unrealistic, yes, but funny enough thou, that many "systems" out there already have those approaches in them * but they suffer simply from ... ... ... being an enclosed "system", which encapsulates itself by being a "finished" system which tries to stretch its own boundaries then again, tries to "grow" with each version out of its own set limits *  which renders most of these goals obsolete because of conceptual hindrance (falling in each others way) * the better approach is to simply provide heterogenic **builders** or bundles of heterogenic **builders** which can build all together a temporary homogenic entity simulating a resiliently service interface, raising constructs which collide data based on rules * no frozen methods * no fixed systematic * don't think of a system * think of  a system-builder * that's the trick * don't think of providing "features" * think of providing the "methods" and smart "rules" (APIs) to make it possible to build flexible bundled "feature-sets" and pack it in UI to be expandable without coding * on the end you have a lego play system where you can plug and play APIs to create stunning nerds :-)

### NERD fantasy road map and possible "features" (better say "rules", since features are limitless)

 + Not an enforced enclosed system, rather a system builder, extending on the power of data relations
 + limitless BUT understandable builder admin concept, to build admin UI like everything else
 + MVC / DRY / OOP
 + force unique data values and function singularity, consistency
 + Never hard code, keep always pluggable modularity
 + uncoupled small and single reusable unique value bundles and functions
 + workflow API, a relation technique but for existing functionality to create complex functionality bundles
 + Don't couple functionality like coding a system! Only code the builder methods for building flexible systems without code!
 + smart function compatibility to prevent hindrance for new functions
 + Important: readable self explanatory code!
 + code comments in documentation style to build docs from comments
 + data management and evaluation first: an admin interface should be able to function like code!
 + unique reusable data value consistency (e.g.: address is not the same data table like names, names can have many addresses, a.s.o.)
 + never mix data management and data display, never! these are 2 different APIs
 + central data storage, accessible from unlimited directions
 + multi-domain / multi address management and contextual separation methods to let the base act like many bases
 + advanced permission system, levels, types, groups
 + multi language and data translation management
 + complex data relation flexibility by default, multidimensional relations
 + application first, presentation last
 + no abstraction layer mess, no mass compatibility to reach brighter audience
 + reach out with smart functionality and quality for the smart users! not with over-whole compatibility to reach all user by risking layer overload
 + clean the street for speed 
 + data evaluation builder API
 + field-able data input form API depending on data bundler API
 + field-able data bundler API 
 + no mark up in methods! no presentation structures mixed with functionality!
 + act like an EDP system which (also) can render webpages or browser based UI, not upside down
 + plugin API to extend for different data display engines, theme engines, data evaluation methods. Keep it open, clean, transparent and code familiar. NO NEW terminology concept to learn!
 + Embrace modern web technologies like node.js, rvm based local ruby and gems, sass, compass, jquery, singularitygs, breakpoint
 + make the whole idea adaptable. don't think of it as a encapsulated entity. think of it like learning code or sociable molecules
 + BUT! Don't refuse proofed techniques only because they feel like legacy. php, python, perl, what works best, they all have their very true reason to exist.
 + DON'T follow every new hype. Be smart. Watch. Learn. Adapt not too early and not too late...
 + keep the singularity, keep each rule and each method/function simple and maintainable

### Possible APIs

 + input validation API (extends form API to build rules and data input types, regex, unlimited)
 + render API (creates simple data structure theming interfaces for mark up PLUGINS like html or xml or others based on requests and involved bundles)
 + data or bundle relation API (uses cross ID database tables to create Filemaker-like relations)
 + condition API (to build if then scenarios)
 + form API (extends relation API)

Don't wonder what this nonsense is all about here. It is an idea scratch pad with unsorted outlines to create a new way of thinking about what code should provide in the new era of mobility, networking, clouding and service sharing. In a world of upcoming legacy of traditional software structure, traditional home PC's, traditional web application structure and desktop user behavior. And even the new is already old and shares too much with the *usual way*. I think that the behavior of user and code will merge, will come closer to each other, to keep up the promised freedom these new technologies wanted to provide. And since the user already made big steps in direction code, the code should start to make big steps in direction user. And the biggest misunderstanding is to think the user is stupid and needs a passed on "user interface". That was new these days. But this is old now and the time is over. Keeping this tradition is only for own interest of some who try to keep control over the secrets of code. The truth is, the digital nation isn't computer scared no more, isn't scared of pluggable computer functionality and code logic and isn't afraid of using complex interfaces to accomplish something, if this keeps flexibility and makes more possible. Code should not provide entities, code should provide possibilities. Most user frustration today comes from limits the software shows off, not from not understanding how to use it. This ends up with so called user work arounds. And this is actually what a system causes: workarounds the system. And these workarounds actually  are methodological what nerd is: modular functionality adaptable to the users use case.
