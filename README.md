Narrative Expression of Related Data = NERD
===========================================

A scratch pad for an API driven, pluggable, modular server-based data evaluation and input/output system builder, focused on data and its structure, limitless extendable and free of any suggested structure like CMS, but with all options available. Like, you *can* provide a system with a browser based interface behavior for web applications, but you don't need to!  Or provide terminal support for math evaluation algorithms. This way (rather upside down in opposite to the traditional way) it makes it possible to build limitless (web) applications and services * UI masks * web sites * social networks * pin-boards * blogs * and even (like the name suggests) complex Extended Data Processing systems like project managements or company base managements, bundling *real* modular functionality and building extendable method boilerplates, which can adapt almost everything thinkable.

+ Separating the User Interface from the Business Logic.
+ Focus on mechanisms to make bundling data or fields of data to groups and views administratable by the user, rather than on static data<->view contructs and expanding them again and again.
+ Don't think in a single use-case to develop for, rather build blocks to be able to constuct for use-cases on it.
+ So don't think of a web application. Think into the future: think of applications with different interfaces and maybe one for the web, if a so called web still exist in the time of the first release of this here.

Many *systems* out there already follow such approaches but suffer from the fact that these are enclosed *systems* not peaces of building blocks, which encapsulates itself by being a "finished" system trying to stretch its own boundaries then again, trying to "grow" with each version out of its own limits from being a system, which renders most of these approaches obsolete by its own conceptual hindrance (falling in each others way).

The better way to accomplish this is to simply provide heterogenic **building blocks** and bundles of such heterogenic building blocks which can bundle and build all together a temporary homogenic entity, simulating a resiliently service interface, raising constructs which collide data based on rules.

no frozen methods * no fixed systematic * don't think of a system * think of  a system-builder * that's the trick * don't think of providing "features" * think of providing the "methods" and smart "rules" (APIs) to make it possible to build flexible bundled "feature-sets" and pack it in UI to be expandable without coding * on the end you have a lego play system where you can plug and play APIs to create stunning nerds :-)

 + as simple as dragging and dropping code blocks which "understand" each other out of the box
 + Not an enforced enclosed system, rather a system builder, extending on the power of data relations
 + limitless BUT understandable builder admin concept, to build admin UI like everything else
 + MVC / DRY / OOP
 + data and function singularity to follow consistency paradigm for both: data structure and functionality
 + pluggable modularity. always! Never hard code use-cases!
 + build small peaces to create bigger ones: uncoupled small and single reusable unique value bundles and functions
 + workflow API, a relation technique but for existing functionality to create complex functionality bundles
 + Don't couple functionality like coding a system! Only code the builder methods for building flexible systems without code!
 + smart function compatibility to prevent hindrance for new functions
 + Important: readable self explanatory code!
 + code comments in documentation style to build docs from comments
 + data management and evaluation first: an admin interface should be able to function like code!
 + unique reusable data value consistency (e.g.: address is not the same data table like names, names can have many addresses, a.s.o.)
 + never mix data management and data display, never! these are 2 different APIs
 + central data storage, accessible from unlimited directions
 + multi-domain / multi address management and contextual separation methods to let the base act like many bases
 + advanced permission system, levels, types, groups
 + multi language and data translation management
 + complex data relation flexibility by default, multidimensional relations
 + application first, presentation last
 + no abstraction layer mess, no mass compatibility to reach brighter audience
 + reach out with smart functionality and quality for the smart users! not with over-whole compatibility from scratch to reach all user by risking layer overload
 + clean the street for speed 
 + data evaluation builder API
 + field-able data input form API depending on data bundler API
 + field-able data bundler API 
 + no mark up in code! no presentation structures mixed with functionality!
 + act like an EDP system which (also) can render webpages or browser based UI, not upside down
 + plugin API to extend for different data display engines, theme engines, data evaluation methods. Keep it open, clean, transparent and code familiar. NO NEW terminology concept to learn!
 + Embrace modern web technologies like node.js, rvm based local ruby and gems, sass, compass, jquery, singularitygs, breakpoint
 + make the whole idea adaptable. don't think of it as a encapsulated entity. think of it like learning code or sociable molecules
 + BUT! Don't refuse proofed techniques only because they feel like legacy. php, python, perl, what works best, they all have their very true reason to exist.
 + DON'T follow every new hype. Be smart. Watch. Learn. Adapt not too early and not too late...
 + keep the singularity, keep each rule and each method/function simple and maintainable

### Possible APIs

 + input validation API (extends form API to build rules and data input types, regex, unlimited)
 + render API (creates simple data structure theming interfaces for mark up PLUGINS like html or xml or others based on requests and involved bundles)
 + data or bundle relation API (uses cross ID database tables to create Filemaker-like relations)
 + condition API (to build if then scenarios)
 + form API (extends relation API)

Don't wonder what this nonsense is all about here. It is an idea scratch pad with unsorted outlines to create a new way of thinking about what code should provide in the new era of mobility, networking, clouding and service sharing. In a world of upcoming legacy of traditional software structure, traditional home PC's, traditional web application structure and desktop user behavior. And even the new is already old and shares too much with the *usual way*. I think that the behavior of user and code will merge, will come closer to each other, to keep up the promised freedom these new technologies wanted to provide. And since the user already made big steps in direction code, the code should start to make big steps in direction user. And the biggest misunderstanding is to think the user is stupid and needs a passed on "user interface". That was new these days. But this is old now and the time is over. Keeping this tradition is only for own interest of some who try to keep control over the secrets of code. The truth is, the digital nation isn't computer scared no more, isn't scared of pluggable computer functionality and code logic and isn't afraid of using complex interfaces to accomplish something, if this keeps flexibility and makes more possible. Code should not provide entities, code should provide possibilities. Most user frustration today comes from limits the software shows off, not from not understanding how to use it. This ends up with so called **user workarounds**. 

And this is actually what a system causes: workarounds around the system. And these workarounds actually are methodological what **nerd** is: **modular functionality adaptable to the users use case**.
